#!/usr/bin/env bash

# Copyright (C) 2025 Koni Marti <koni.marti@gmail.com>. All Rights Reserved.
# This file is licensed under the MIT.

set -o pipefail

[[ ! -z "$DEBUGC3L" ]] && set -x

C3C="c3c"
SED="${SED:-sed --posix}"
PROJECT="project.json"
RECORDS=".c3l.deps"
GITARGS=( "--depth 1" "--quiet" "--recurse-submodules" )
#
# Utility functions
#
git_clone() {
	local root_dir="$1"
	local repo_url="$2"
	local output_dir="$3"
	[[ -n "$4" ]] && GITARGS+=( "--branch $4" )
	if [[ -z "$LOCALREPO" ]]; then
		git -C "$root_dir" clone ${GITARGS[@]} "$repo_url" "$output_dir" 2>/dev/null \
		&& info "git repo created from $repo_url" \
		|| die "failed to create $repo_url"
	else
		cp -r "$LOCALREPO" "$root_dir/$output_dir"
		info "Use local repo $LOCALREPO"
	fi
}
pack_library() {
	local archive="$1";
	local directory="$C3LTMPDIR/$2"
	(cd "$directory" && zip -r0 $archive "." >/dev/null) ||
		die "failed to pack library"
	info "library packed as $repo_name"
}
add_dependency() {
	check_project_or_die
	load_dependencies
	local dep="$(basename $1 .c3l)";
	[[ "${#DEPENDENCIES[@]}" == 0 ]] && comma="" || comma=","
	[[ " ${DEPENDENCIES[@]} " =~ " ${dep} " ]] ||
		$SED -i "/\"dependencies\"/{s/\[/\[ \"$dep\"$comma /}" "$PROJECT"
	info "add $dep as a dependency in $PROJECT"
}
load_dependencies() {
	check_project_or_die
	IFS=, read -ra DEPENDENCIES <<< "$($C3C project view | grep "dependencies" | cut -d':' -f2)"
}
load_searchpaths() {
	check_project_or_die
	IFS=, read -ra SEARCHPATHS <<< "$($C3C project view | grep "search paths" | cut -d':' -f2)"
}
get_searchpath() {
	load_searchpaths
	$SED 's/^ *//;s/ *$//;' <<< "${SEARCHPATHS[0]}"
}
make_target_dir() {
	local target_dir="$1"
	[[ -n "$target_dir" ]] || die "no directory found in dependency-search-paths"
	[[ -d "$target_dir" ]] || (mkdir "$target_dir" && info "directory $target_dir created")
}
hash_directory() {
	local root_dir="$1"
	local ouput_dir="$2"
	HASH=$(tar -C $root_dir -cf - --sort=name $output_dir | sha256sum)
}
check_project_or_die() {
	[[ -f "$PROJECT" ]] || die "'$PROJECT' not found. Did you create a c3c project?"
}
yesno() {
	[[ -t 0 ]] || return 0
	local response
	read -r -p "$1 [y/N] " response
	[[ $response == [yY] ]] || exit 1
}
get_record() {
	echo $([[ -f "$RECORDS" ]] && grep "^${repo_name} " "$RECORDS" 2>/dev/null)
}
valid_semver() {
	[[ "$1" =~ ^v?[0-9]+(\.[0-9]+){1,2}(-[0-9A-Za-z.-]+)?$ ]]
}
cmp_semver() {
	[[ $# != 2 ]] && die "cmp_semver: expects two arguments"
	local v1="$1"
	local v2="$2"

	# Strip leading 'v' if present
	v1="${v1#v}"
	v2="${v2#v}"

	# Split into arrays
	IFS=. read -r v1_major v1_minor v1_patch <<<"$v1"
	IFS=. read -r v2_major v2_minor v2_patch <<<"$v2"

	# Default missing parts to 0
	v1_minor=${v1_minor:-0}
	v1_patch=${v1_patch:-0}
	v2_minor=${v2_minor:-0}
	v2_patch=${v2_patch:-0}

	# Compare major
	if (( 10#$v1_major > 10#$v2_major )); then
	    echo 1; return
	elif (( 10#$v1_major < 10#$v2_major )); then
	    echo -1; return
	fi

	# Compare minor
	if (( 10#$v1_minor > 10#$v2_minor )); then
	    echo 1; return
	elif (( 10#$v1_minor < 10#$v2_minor )); then
	    echo -1; return
	fi

	# Compare patch
	if (( 10#$v1_patch > 10#$v2_patch )); then
	    echo 1; return
	elif (( 10#$v1_patch < 10#$v2_patch )); then
	    echo -1; return
	fi

	# Equal
	echo 0
}
get_highest_semver() {
	local repo_url="$1"
	git ls-remote --tags --sort="v:refname" "$repo_url" \
		| awk -F/ '{print $3}' \
		| grep -v '\^{}' \
		| grep -E '^v?[0-9]+(\.[0-9]+){1,2}(-[0-9A-Za-z.-]+)?$' \
		| tail -n 1
}
info() {
	printf "\e[32m%s\e[0m %s\n" "[INFO]" "$@"
}
warn() {
	printf "\e[33m%s\e[0m %s\n" "[WARN]" "$@"
}
die() {
	printf "\e[31m%s\e[0m %s\n" "[ERROR]" "$@" >&2
	exit 1
}
tmpdir() {
	[[ -n $C3LTMPDIR ]] && return
	local template="$PROGRAM.XXXXXXXXXXXXX"
	C3LTMPDIR="$(mktemp -d "$template")"
	remove_tmpfile() {
		rm -rf "$C3LTMPDIR"
	}
	trap remove_tmpfile EXIT
}

#
# Subcommand functions
#

cmd_version() {
	cat <<-_EOF
	******************************************
	*       c3l: the C3 library manager      *
	*                                        *
	*                v0.0.0                  *
	*                                        *
	*              Koni Marti                *
	*          koni.marti@gmail.com          *
	*                                        *
	******************************************
	_EOF
}

cmd_usage() {
	cmd_version
	echo
	cat <<-_EOF
	Usage:
	    $PROGRAM fetch repo_url [tag]
		Fetch a C3 library from repo_url and add it to the C3 project.
		An optional tag version can be specified (i.e. v1.0.0).
	    $PROGRAM remove libname
		Remove the C3 library from the C3 project.
	    $PROGRAM update libname
		Update the C3 library to the newest tagged release. If no tag
		version was saved during fetching, the library is updated to
		the newest commit.
	    $PROGRAM list
	        List the installed libraries.
	    $PROGRAM help
	        Show this text.
	    $PROGRAM version
	        Show version information.

	More information may be found in the c3l(1) man page.
	_EOF
}

cmd_fetch() {
	(( $# == 0 )) && die "Usage: $PROGRAM $COMMAND repo_url [tag]"
	local repo_url="$1"
	local repo_name="$(basename $1 .git)"
	local tag_name="$2"
	local archive_name="${repo_name}.zip"
	local target_dir=$(get_searchpath)

	[[ -n "$(get_record $repo_name)" ]] && die "$repo_name is already installed. If you want to remove it, run 'c3l remove $repo_name'"

	tmpdir # defines $C3LTMPDIR
	make_target_dir $target_dir
	git_clone "$C3LTMPDIR" "$repo_url" "$repo_name" "$tag_name"
	pack_library "$archive_name" "$repo_name"

	mv "$C3LTMPDIR/$repo_name/$archive_name" "$target_dir/$repo_name"
	info "library installed at $target_dir/$repo_name"

	add_dependency "$repo_name"
	echo "$repo_name $target_dir/$repo_name $repo_url $tag_name" >> "$RECORDS"
}

cmd_remove() {
	(( $# == 0 )) && die "Usage: $PROGRAM $COMMAND libname"
	local repo_name="$1"
	local dep="$(basename $repo_name .c3l)"
	local record=( )
	read -ra record <<< "$(get_record $repo_name)"

	if [[ -z "$record" ]]; then
		local target_dir=$(get_searchpath)
		[[ -n "$target_dir" ]] || die "no directory found in dependency-search-paths"
		[[ -d "$target_dir" ]] || die "directory $target_dir does not exist"
		[[ -f "$target_dir/$repo_name" ]] || die "$target_dir/$repo_name does not exist"
		rm "$target_dir/$repo_name" 2>/dev/null && info "$target_dir/$repo_name removed"
	else
		[[ -f "${record[1]}" ]] || die "${record[1]} does not exist"
		rm "${record[1]}" 2>/dev/null && info "${record[1]} removed"
	fi

	$SED -i "/\"dependencies\"/s/\"${dep}\"[, ]*//" "$PROJECT" && info "$PROJECT updated" || warn "failed to update $PROJECT"
	$SED -i "/^$repo_name/d" "$RECORDS" && info "records updated" || warn "failed to update $RECORDS"
}

cmd_update() {
	(( $# == 0 )) && die "Usage: $PROGRAM $COMMAND libname"
	local repo_name="$1"
	local dep="$(basename $repo_name .c3l)"
	local record=( )
	read -ra record <<< "$(get_record $repo_name)"
	local repo_url tag len
	len="${#record[@]}"

	(( $len == 0 )) && die "no record found for $repo_name"
	(( $len >= 2 )) && repo_url="${record[2]}"
	(( $len >= 3 )) && tag="${record[3]}"

	if [[ -n "$tag" && -n "$repo_url" ]]; then
		local newest_tag="$(get_highest_semver $repo_url)"
		valid_semver $tag || die "$tag appears not to be a valid semantic version"
		valid_semver $newest_tag || die "$newest_tag appears not to be a valid semantic version"
		if (( $(cmp_semver "$newest_tag" "$tag") > 0 )); then
			cmd_remove $repo_name
			cmd_fetch $repo_url $newest_tag
			info "$repo_name updated: $tag ==> $newest_tag"
		else
			info "nothing to do here ($newest_tag <= $tag)"
		fi
	elif [[ -n "$repo_url" ]]; then
		cmd_remove $repo_name
		cmd_fetch $repo_url
		info "$repo_name updated"
	else
		die "neither a 'repo_url' nor a 'tag' was found in $RECORDS"
	fi
}

cmd_list() {
	local rem
	while read -ra line; do
		rem="${line[@]:1}"
		printf "\e[92m%s\e[0m %s\n" "${line[0]}" "$rem"
	done < "$RECORDS"
}

#
# END subcommand functions
#

PROGRAM="${0##*/}"
COMMAND="$1"

case "$1" in
	help|--help) shift;		cmd_usage "$@" ;;
	version|--version) shift;	cmd_version "$@" ;;
	fetch|f|get|g) shift;		cmd_fetch "$@" ;;
	update|u) shift;		cmd_update "$@" ;;
	list|ls|l) shift;		cmd_list "$@" ;;
	delete|remove|rm|r) shift;	cmd_remove "$@" ;;
	*)				cmd_usage "$@" ;;
esac
exit 0
